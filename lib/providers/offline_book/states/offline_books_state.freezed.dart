// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'offline_books_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$OfflineBooksState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<BookGroup> bookGroups) loaded,
    required TResult Function() empty,
    required TResult Function(Object? error, StackTrace? stackTrace) loadError,
    required TResult Function(List<BookGroup> bookGroups) removed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<BookGroup> bookGroups)? loaded,
    TResult? Function()? empty,
    TResult? Function(Object? error, StackTrace? stackTrace)? loadError,
    TResult? Function(List<BookGroup> bookGroups)? removed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<BookGroup> bookGroups)? loaded,
    TResult Function()? empty,
    TResult Function(Object? error, StackTrace? stackTrace)? loadError,
    TResult Function(List<BookGroup> bookGroups)? removed,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OfflineBooksInitial value) initial,
    required TResult Function(OfflineBooksLoading value) loading,
    required TResult Function(OfflineBooksLoaded value) loaded,
    required TResult Function(OfflineBooksEmpty value) empty,
    required TResult Function(OfflineBooksLoadError value) loadError,
    required TResult Function(OfflineBooksRemoved value) removed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(OfflineBooksInitial value)? initial,
    TResult? Function(OfflineBooksLoading value)? loading,
    TResult? Function(OfflineBooksLoaded value)? loaded,
    TResult? Function(OfflineBooksEmpty value)? empty,
    TResult? Function(OfflineBooksLoadError value)? loadError,
    TResult? Function(OfflineBooksRemoved value)? removed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OfflineBooksInitial value)? initial,
    TResult Function(OfflineBooksLoading value)? loading,
    TResult Function(OfflineBooksLoaded value)? loaded,
    TResult Function(OfflineBooksEmpty value)? empty,
    TResult Function(OfflineBooksLoadError value)? loadError,
    TResult Function(OfflineBooksRemoved value)? removed,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OfflineBooksStateCopyWith<$Res> {
  factory $OfflineBooksStateCopyWith(
          OfflineBooksState value, $Res Function(OfflineBooksState) then) =
      _$OfflineBooksStateCopyWithImpl<$Res, OfflineBooksState>;
}

/// @nodoc
class _$OfflineBooksStateCopyWithImpl<$Res, $Val extends OfflineBooksState>
    implements $OfflineBooksStateCopyWith<$Res> {
  _$OfflineBooksStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$OfflineBooksInitialCopyWith<$Res> {
  factory _$$OfflineBooksInitialCopyWith(_$OfflineBooksInitial value,
          $Res Function(_$OfflineBooksInitial) then) =
      __$$OfflineBooksInitialCopyWithImpl<$Res>;
}

/// @nodoc
class __$$OfflineBooksInitialCopyWithImpl<$Res>
    extends _$OfflineBooksStateCopyWithImpl<$Res, _$OfflineBooksInitial>
    implements _$$OfflineBooksInitialCopyWith<$Res> {
  __$$OfflineBooksInitialCopyWithImpl(
      _$OfflineBooksInitial _value, $Res Function(_$OfflineBooksInitial) _then)
      : super(_value, _then);
}

/// @nodoc

class _$OfflineBooksInitial extends OfflineBooksInitial {
  _$OfflineBooksInitial() : super._();

  @override
  String toString() {
    return 'OfflineBooksState.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$OfflineBooksInitial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<BookGroup> bookGroups) loaded,
    required TResult Function() empty,
    required TResult Function(Object? error, StackTrace? stackTrace) loadError,
    required TResult Function(List<BookGroup> bookGroups) removed,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<BookGroup> bookGroups)? loaded,
    TResult? Function()? empty,
    TResult? Function(Object? error, StackTrace? stackTrace)? loadError,
    TResult? Function(List<BookGroup> bookGroups)? removed,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<BookGroup> bookGroups)? loaded,
    TResult Function()? empty,
    TResult Function(Object? error, StackTrace? stackTrace)? loadError,
    TResult Function(List<BookGroup> bookGroups)? removed,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OfflineBooksInitial value) initial,
    required TResult Function(OfflineBooksLoading value) loading,
    required TResult Function(OfflineBooksLoaded value) loaded,
    required TResult Function(OfflineBooksEmpty value) empty,
    required TResult Function(OfflineBooksLoadError value) loadError,
    required TResult Function(OfflineBooksRemoved value) removed,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(OfflineBooksInitial value)? initial,
    TResult? Function(OfflineBooksLoading value)? loading,
    TResult? Function(OfflineBooksLoaded value)? loaded,
    TResult? Function(OfflineBooksEmpty value)? empty,
    TResult? Function(OfflineBooksLoadError value)? loadError,
    TResult? Function(OfflineBooksRemoved value)? removed,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OfflineBooksInitial value)? initial,
    TResult Function(OfflineBooksLoading value)? loading,
    TResult Function(OfflineBooksLoaded value)? loaded,
    TResult Function(OfflineBooksEmpty value)? empty,
    TResult Function(OfflineBooksLoadError value)? loadError,
    TResult Function(OfflineBooksRemoved value)? removed,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class OfflineBooksInitial extends OfflineBooksState {
  factory OfflineBooksInitial() = _$OfflineBooksInitial;
  OfflineBooksInitial._() : super._();
}

/// @nodoc
abstract class _$$OfflineBooksLoadingCopyWith<$Res> {
  factory _$$OfflineBooksLoadingCopyWith(_$OfflineBooksLoading value,
          $Res Function(_$OfflineBooksLoading) then) =
      __$$OfflineBooksLoadingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$OfflineBooksLoadingCopyWithImpl<$Res>
    extends _$OfflineBooksStateCopyWithImpl<$Res, _$OfflineBooksLoading>
    implements _$$OfflineBooksLoadingCopyWith<$Res> {
  __$$OfflineBooksLoadingCopyWithImpl(
      _$OfflineBooksLoading _value, $Res Function(_$OfflineBooksLoading) _then)
      : super(_value, _then);
}

/// @nodoc

class _$OfflineBooksLoading extends OfflineBooksLoading {
  _$OfflineBooksLoading() : super._();

  @override
  String toString() {
    return 'OfflineBooksState.loading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$OfflineBooksLoading);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<BookGroup> bookGroups) loaded,
    required TResult Function() empty,
    required TResult Function(Object? error, StackTrace? stackTrace) loadError,
    required TResult Function(List<BookGroup> bookGroups) removed,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<BookGroup> bookGroups)? loaded,
    TResult? Function()? empty,
    TResult? Function(Object? error, StackTrace? stackTrace)? loadError,
    TResult? Function(List<BookGroup> bookGroups)? removed,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<BookGroup> bookGroups)? loaded,
    TResult Function()? empty,
    TResult Function(Object? error, StackTrace? stackTrace)? loadError,
    TResult Function(List<BookGroup> bookGroups)? removed,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OfflineBooksInitial value) initial,
    required TResult Function(OfflineBooksLoading value) loading,
    required TResult Function(OfflineBooksLoaded value) loaded,
    required TResult Function(OfflineBooksEmpty value) empty,
    required TResult Function(OfflineBooksLoadError value) loadError,
    required TResult Function(OfflineBooksRemoved value) removed,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(OfflineBooksInitial value)? initial,
    TResult? Function(OfflineBooksLoading value)? loading,
    TResult? Function(OfflineBooksLoaded value)? loaded,
    TResult? Function(OfflineBooksEmpty value)? empty,
    TResult? Function(OfflineBooksLoadError value)? loadError,
    TResult? Function(OfflineBooksRemoved value)? removed,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OfflineBooksInitial value)? initial,
    TResult Function(OfflineBooksLoading value)? loading,
    TResult Function(OfflineBooksLoaded value)? loaded,
    TResult Function(OfflineBooksEmpty value)? empty,
    TResult Function(OfflineBooksLoadError value)? loadError,
    TResult Function(OfflineBooksRemoved value)? removed,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class OfflineBooksLoading extends OfflineBooksState {
  factory OfflineBooksLoading() = _$OfflineBooksLoading;
  OfflineBooksLoading._() : super._();
}

/// @nodoc
abstract class _$$OfflineBooksLoadedCopyWith<$Res> {
  factory _$$OfflineBooksLoadedCopyWith(_$OfflineBooksLoaded value,
          $Res Function(_$OfflineBooksLoaded) then) =
      __$$OfflineBooksLoadedCopyWithImpl<$Res>;
  @useResult
  $Res call({List<BookGroup> bookGroups});
}

/// @nodoc
class __$$OfflineBooksLoadedCopyWithImpl<$Res>
    extends _$OfflineBooksStateCopyWithImpl<$Res, _$OfflineBooksLoaded>
    implements _$$OfflineBooksLoadedCopyWith<$Res> {
  __$$OfflineBooksLoadedCopyWithImpl(
      _$OfflineBooksLoaded _value, $Res Function(_$OfflineBooksLoaded) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? bookGroups = null,
  }) {
    return _then(_$OfflineBooksLoaded(
      bookGroups: null == bookGroups
          ? _value._bookGroups
          : bookGroups // ignore: cast_nullable_to_non_nullable
              as List<BookGroup>,
    ));
  }
}

/// @nodoc

class _$OfflineBooksLoaded extends OfflineBooksLoaded {
  _$OfflineBooksLoaded({required final List<BookGroup> bookGroups})
      : _bookGroups = bookGroups,
        super._();

  final List<BookGroup> _bookGroups;
  @override
  List<BookGroup> get bookGroups {
    if (_bookGroups is EqualUnmodifiableListView) return _bookGroups;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_bookGroups);
  }

  @override
  String toString() {
    return 'OfflineBooksState.loaded(bookGroups: $bookGroups)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$OfflineBooksLoaded &&
            const DeepCollectionEquality()
                .equals(other._bookGroups, _bookGroups));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_bookGroups));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$OfflineBooksLoadedCopyWith<_$OfflineBooksLoaded> get copyWith =>
      __$$OfflineBooksLoadedCopyWithImpl<_$OfflineBooksLoaded>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<BookGroup> bookGroups) loaded,
    required TResult Function() empty,
    required TResult Function(Object? error, StackTrace? stackTrace) loadError,
    required TResult Function(List<BookGroup> bookGroups) removed,
  }) {
    return loaded(bookGroups);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<BookGroup> bookGroups)? loaded,
    TResult? Function()? empty,
    TResult? Function(Object? error, StackTrace? stackTrace)? loadError,
    TResult? Function(List<BookGroup> bookGroups)? removed,
  }) {
    return loaded?.call(bookGroups);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<BookGroup> bookGroups)? loaded,
    TResult Function()? empty,
    TResult Function(Object? error, StackTrace? stackTrace)? loadError,
    TResult Function(List<BookGroup> bookGroups)? removed,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(bookGroups);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OfflineBooksInitial value) initial,
    required TResult Function(OfflineBooksLoading value) loading,
    required TResult Function(OfflineBooksLoaded value) loaded,
    required TResult Function(OfflineBooksEmpty value) empty,
    required TResult Function(OfflineBooksLoadError value) loadError,
    required TResult Function(OfflineBooksRemoved value) removed,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(OfflineBooksInitial value)? initial,
    TResult? Function(OfflineBooksLoading value)? loading,
    TResult? Function(OfflineBooksLoaded value)? loaded,
    TResult? Function(OfflineBooksEmpty value)? empty,
    TResult? Function(OfflineBooksLoadError value)? loadError,
    TResult? Function(OfflineBooksRemoved value)? removed,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OfflineBooksInitial value)? initial,
    TResult Function(OfflineBooksLoading value)? loading,
    TResult Function(OfflineBooksLoaded value)? loaded,
    TResult Function(OfflineBooksEmpty value)? empty,
    TResult Function(OfflineBooksLoadError value)? loadError,
    TResult Function(OfflineBooksRemoved value)? removed,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class OfflineBooksLoaded extends OfflineBooksState {
  factory OfflineBooksLoaded({required final List<BookGroup> bookGroups}) =
      _$OfflineBooksLoaded;
  OfflineBooksLoaded._() : super._();

  List<BookGroup> get bookGroups;
  @JsonKey(ignore: true)
  _$$OfflineBooksLoadedCopyWith<_$OfflineBooksLoaded> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$OfflineBooksEmptyCopyWith<$Res> {
  factory _$$OfflineBooksEmptyCopyWith(
          _$OfflineBooksEmpty value, $Res Function(_$OfflineBooksEmpty) then) =
      __$$OfflineBooksEmptyCopyWithImpl<$Res>;
}

/// @nodoc
class __$$OfflineBooksEmptyCopyWithImpl<$Res>
    extends _$OfflineBooksStateCopyWithImpl<$Res, _$OfflineBooksEmpty>
    implements _$$OfflineBooksEmptyCopyWith<$Res> {
  __$$OfflineBooksEmptyCopyWithImpl(
      _$OfflineBooksEmpty _value, $Res Function(_$OfflineBooksEmpty) _then)
      : super(_value, _then);
}

/// @nodoc

class _$OfflineBooksEmpty extends OfflineBooksEmpty {
  _$OfflineBooksEmpty() : super._();

  @override
  String toString() {
    return 'OfflineBooksState.empty()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$OfflineBooksEmpty);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<BookGroup> bookGroups) loaded,
    required TResult Function() empty,
    required TResult Function(Object? error, StackTrace? stackTrace) loadError,
    required TResult Function(List<BookGroup> bookGroups) removed,
  }) {
    return empty();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<BookGroup> bookGroups)? loaded,
    TResult? Function()? empty,
    TResult? Function(Object? error, StackTrace? stackTrace)? loadError,
    TResult? Function(List<BookGroup> bookGroups)? removed,
  }) {
    return empty?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<BookGroup> bookGroups)? loaded,
    TResult Function()? empty,
    TResult Function(Object? error, StackTrace? stackTrace)? loadError,
    TResult Function(List<BookGroup> bookGroups)? removed,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OfflineBooksInitial value) initial,
    required TResult Function(OfflineBooksLoading value) loading,
    required TResult Function(OfflineBooksLoaded value) loaded,
    required TResult Function(OfflineBooksEmpty value) empty,
    required TResult Function(OfflineBooksLoadError value) loadError,
    required TResult Function(OfflineBooksRemoved value) removed,
  }) {
    return empty(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(OfflineBooksInitial value)? initial,
    TResult? Function(OfflineBooksLoading value)? loading,
    TResult? Function(OfflineBooksLoaded value)? loaded,
    TResult? Function(OfflineBooksEmpty value)? empty,
    TResult? Function(OfflineBooksLoadError value)? loadError,
    TResult? Function(OfflineBooksRemoved value)? removed,
  }) {
    return empty?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OfflineBooksInitial value)? initial,
    TResult Function(OfflineBooksLoading value)? loading,
    TResult Function(OfflineBooksLoaded value)? loaded,
    TResult Function(OfflineBooksEmpty value)? empty,
    TResult Function(OfflineBooksLoadError value)? loadError,
    TResult Function(OfflineBooksRemoved value)? removed,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class OfflineBooksEmpty extends OfflineBooksState {
  factory OfflineBooksEmpty() = _$OfflineBooksEmpty;
  OfflineBooksEmpty._() : super._();
}

/// @nodoc
abstract class _$$OfflineBooksLoadErrorCopyWith<$Res> {
  factory _$$OfflineBooksLoadErrorCopyWith(_$OfflineBooksLoadError value,
          $Res Function(_$OfflineBooksLoadError) then) =
      __$$OfflineBooksLoadErrorCopyWithImpl<$Res>;
  @useResult
  $Res call({Object? error, StackTrace? stackTrace});
}

/// @nodoc
class __$$OfflineBooksLoadErrorCopyWithImpl<$Res>
    extends _$OfflineBooksStateCopyWithImpl<$Res, _$OfflineBooksLoadError>
    implements _$$OfflineBooksLoadErrorCopyWith<$Res> {
  __$$OfflineBooksLoadErrorCopyWithImpl(_$OfflineBooksLoadError _value,
      $Res Function(_$OfflineBooksLoadError) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = freezed,
    Object? stackTrace = freezed,
  }) {
    return _then(_$OfflineBooksLoadError(
      error: freezed == error ? _value.error : error,
      stackTrace: freezed == stackTrace
          ? _value.stackTrace
          : stackTrace // ignore: cast_nullable_to_non_nullable
              as StackTrace?,
    ));
  }
}

/// @nodoc

class _$OfflineBooksLoadError extends OfflineBooksLoadError {
  _$OfflineBooksLoadError({this.error, this.stackTrace}) : super._();

  @override
  final Object? error;
  @override
  final StackTrace? stackTrace;

  @override
  String toString() {
    return 'OfflineBooksState.loadError(error: $error, stackTrace: $stackTrace)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$OfflineBooksLoadError &&
            const DeepCollectionEquality().equals(other.error, error) &&
            (identical(other.stackTrace, stackTrace) ||
                other.stackTrace == stackTrace));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(error), stackTrace);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$OfflineBooksLoadErrorCopyWith<_$OfflineBooksLoadError> get copyWith =>
      __$$OfflineBooksLoadErrorCopyWithImpl<_$OfflineBooksLoadError>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<BookGroup> bookGroups) loaded,
    required TResult Function() empty,
    required TResult Function(Object? error, StackTrace? stackTrace) loadError,
    required TResult Function(List<BookGroup> bookGroups) removed,
  }) {
    return loadError(error, stackTrace);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<BookGroup> bookGroups)? loaded,
    TResult? Function()? empty,
    TResult? Function(Object? error, StackTrace? stackTrace)? loadError,
    TResult? Function(List<BookGroup> bookGroups)? removed,
  }) {
    return loadError?.call(error, stackTrace);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<BookGroup> bookGroups)? loaded,
    TResult Function()? empty,
    TResult Function(Object? error, StackTrace? stackTrace)? loadError,
    TResult Function(List<BookGroup> bookGroups)? removed,
    required TResult orElse(),
  }) {
    if (loadError != null) {
      return loadError(error, stackTrace);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OfflineBooksInitial value) initial,
    required TResult Function(OfflineBooksLoading value) loading,
    required TResult Function(OfflineBooksLoaded value) loaded,
    required TResult Function(OfflineBooksEmpty value) empty,
    required TResult Function(OfflineBooksLoadError value) loadError,
    required TResult Function(OfflineBooksRemoved value) removed,
  }) {
    return loadError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(OfflineBooksInitial value)? initial,
    TResult? Function(OfflineBooksLoading value)? loading,
    TResult? Function(OfflineBooksLoaded value)? loaded,
    TResult? Function(OfflineBooksEmpty value)? empty,
    TResult? Function(OfflineBooksLoadError value)? loadError,
    TResult? Function(OfflineBooksRemoved value)? removed,
  }) {
    return loadError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OfflineBooksInitial value)? initial,
    TResult Function(OfflineBooksLoading value)? loading,
    TResult Function(OfflineBooksLoaded value)? loaded,
    TResult Function(OfflineBooksEmpty value)? empty,
    TResult Function(OfflineBooksLoadError value)? loadError,
    TResult Function(OfflineBooksRemoved value)? removed,
    required TResult orElse(),
  }) {
    if (loadError != null) {
      return loadError(this);
    }
    return orElse();
  }
}

abstract class OfflineBooksLoadError extends OfflineBooksState {
  factory OfflineBooksLoadError(
      {final Object? error,
      final StackTrace? stackTrace}) = _$OfflineBooksLoadError;
  OfflineBooksLoadError._() : super._();

  Object? get error;
  StackTrace? get stackTrace;
  @JsonKey(ignore: true)
  _$$OfflineBooksLoadErrorCopyWith<_$OfflineBooksLoadError> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$OfflineBooksRemovedCopyWith<$Res> {
  factory _$$OfflineBooksRemovedCopyWith(_$OfflineBooksRemoved value,
          $Res Function(_$OfflineBooksRemoved) then) =
      __$$OfflineBooksRemovedCopyWithImpl<$Res>;
  @useResult
  $Res call({List<BookGroup> bookGroups});
}

/// @nodoc
class __$$OfflineBooksRemovedCopyWithImpl<$Res>
    extends _$OfflineBooksStateCopyWithImpl<$Res, _$OfflineBooksRemoved>
    implements _$$OfflineBooksRemovedCopyWith<$Res> {
  __$$OfflineBooksRemovedCopyWithImpl(
      _$OfflineBooksRemoved _value, $Res Function(_$OfflineBooksRemoved) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? bookGroups = null,
  }) {
    return _then(_$OfflineBooksRemoved(
      bookGroups: null == bookGroups
          ? _value._bookGroups
          : bookGroups // ignore: cast_nullable_to_non_nullable
              as List<BookGroup>,
    ));
  }
}

/// @nodoc

class _$OfflineBooksRemoved extends OfflineBooksRemoved {
  _$OfflineBooksRemoved({required final List<BookGroup> bookGroups})
      : _bookGroups = bookGroups,
        super._();

  final List<BookGroup> _bookGroups;
  @override
  List<BookGroup> get bookGroups {
    if (_bookGroups is EqualUnmodifiableListView) return _bookGroups;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_bookGroups);
  }

  @override
  String toString() {
    return 'OfflineBooksState.removed(bookGroups: $bookGroups)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$OfflineBooksRemoved &&
            const DeepCollectionEquality()
                .equals(other._bookGroups, _bookGroups));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_bookGroups));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$OfflineBooksRemovedCopyWith<_$OfflineBooksRemoved> get copyWith =>
      __$$OfflineBooksRemovedCopyWithImpl<_$OfflineBooksRemoved>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<BookGroup> bookGroups) loaded,
    required TResult Function() empty,
    required TResult Function(Object? error, StackTrace? stackTrace) loadError,
    required TResult Function(List<BookGroup> bookGroups) removed,
  }) {
    return removed(bookGroups);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<BookGroup> bookGroups)? loaded,
    TResult? Function()? empty,
    TResult? Function(Object? error, StackTrace? stackTrace)? loadError,
    TResult? Function(List<BookGroup> bookGroups)? removed,
  }) {
    return removed?.call(bookGroups);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<BookGroup> bookGroups)? loaded,
    TResult Function()? empty,
    TResult Function(Object? error, StackTrace? stackTrace)? loadError,
    TResult Function(List<BookGroup> bookGroups)? removed,
    required TResult orElse(),
  }) {
    if (removed != null) {
      return removed(bookGroups);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OfflineBooksInitial value) initial,
    required TResult Function(OfflineBooksLoading value) loading,
    required TResult Function(OfflineBooksLoaded value) loaded,
    required TResult Function(OfflineBooksEmpty value) empty,
    required TResult Function(OfflineBooksLoadError value) loadError,
    required TResult Function(OfflineBooksRemoved value) removed,
  }) {
    return removed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(OfflineBooksInitial value)? initial,
    TResult? Function(OfflineBooksLoading value)? loading,
    TResult? Function(OfflineBooksLoaded value)? loaded,
    TResult? Function(OfflineBooksEmpty value)? empty,
    TResult? Function(OfflineBooksLoadError value)? loadError,
    TResult? Function(OfflineBooksRemoved value)? removed,
  }) {
    return removed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OfflineBooksInitial value)? initial,
    TResult Function(OfflineBooksLoading value)? loading,
    TResult Function(OfflineBooksLoaded value)? loaded,
    TResult Function(OfflineBooksEmpty value)? empty,
    TResult Function(OfflineBooksLoadError value)? loadError,
    TResult Function(OfflineBooksRemoved value)? removed,
    required TResult orElse(),
  }) {
    if (removed != null) {
      return removed(this);
    }
    return orElse();
  }
}

abstract class OfflineBooksRemoved extends OfflineBooksState {
  factory OfflineBooksRemoved({required final List<BookGroup> bookGroups}) =
      _$OfflineBooksRemoved;
  OfflineBooksRemoved._() : super._();

  List<BookGroup> get bookGroups;
  @JsonKey(ignore: true)
  _$$OfflineBooksRemovedCopyWith<_$OfflineBooksRemoved> get copyWith =>
      throw _privateConstructorUsedError;
}
