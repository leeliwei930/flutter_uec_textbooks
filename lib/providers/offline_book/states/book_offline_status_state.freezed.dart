// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'book_offline_status_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$BookOfflineStatus {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function() available,
    required TResult Function() unableToDownload,
    required TResult Function(bool isSaving) updating,
    required TResult Function() unavailable,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function()? available,
    TResult? Function()? unableToDownload,
    TResult? Function(bool isSaving)? updating,
    TResult? Function()? unavailable,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function()? available,
    TResult Function()? unableToDownload,
    TResult Function(bool isSaving)? updating,
    TResult Function()? unavailable,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BookOfflineStatusUnknown value) unknown,
    required TResult Function(BookOfflineStatusAvailable value) available,
    required TResult Function(BookOfflineStatusUnableToDownload value)
        unableToDownload,
    required TResult Function(BookOfflineStatusUpdating value) updating,
    required TResult Function(BookOfflineStatusUnavailable value) unavailable,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BookOfflineStatusUnknown value)? unknown,
    TResult? Function(BookOfflineStatusAvailable value)? available,
    TResult? Function(BookOfflineStatusUnableToDownload value)?
        unableToDownload,
    TResult? Function(BookOfflineStatusUpdating value)? updating,
    TResult? Function(BookOfflineStatusUnavailable value)? unavailable,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BookOfflineStatusUnknown value)? unknown,
    TResult Function(BookOfflineStatusAvailable value)? available,
    TResult Function(BookOfflineStatusUnableToDownload value)? unableToDownload,
    TResult Function(BookOfflineStatusUpdating value)? updating,
    TResult Function(BookOfflineStatusUnavailable value)? unavailable,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BookOfflineStatusCopyWith<$Res> {
  factory $BookOfflineStatusCopyWith(
          BookOfflineStatus value, $Res Function(BookOfflineStatus) then) =
      _$BookOfflineStatusCopyWithImpl<$Res, BookOfflineStatus>;
}

/// @nodoc
class _$BookOfflineStatusCopyWithImpl<$Res, $Val extends BookOfflineStatus>
    implements $BookOfflineStatusCopyWith<$Res> {
  _$BookOfflineStatusCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$BookOfflineStatusUnknownCopyWith<$Res> {
  factory _$$BookOfflineStatusUnknownCopyWith(_$BookOfflineStatusUnknown value,
          $Res Function(_$BookOfflineStatusUnknown) then) =
      __$$BookOfflineStatusUnknownCopyWithImpl<$Res>;
}

/// @nodoc
class __$$BookOfflineStatusUnknownCopyWithImpl<$Res>
    extends _$BookOfflineStatusCopyWithImpl<$Res, _$BookOfflineStatusUnknown>
    implements _$$BookOfflineStatusUnknownCopyWith<$Res> {
  __$$BookOfflineStatusUnknownCopyWithImpl(_$BookOfflineStatusUnknown _value,
      $Res Function(_$BookOfflineStatusUnknown) _then)
      : super(_value, _then);
}

/// @nodoc

class _$BookOfflineStatusUnknown extends BookOfflineStatusUnknown {
  const _$BookOfflineStatusUnknown() : super._();

  @override
  String toString() {
    return 'BookOfflineStatus.unknown()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BookOfflineStatusUnknown);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function() available,
    required TResult Function() unableToDownload,
    required TResult Function(bool isSaving) updating,
    required TResult Function() unavailable,
  }) {
    return unknown();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function()? available,
    TResult? Function()? unableToDownload,
    TResult? Function(bool isSaving)? updating,
    TResult? Function()? unavailable,
  }) {
    return unknown?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function()? available,
    TResult Function()? unableToDownload,
    TResult Function(bool isSaving)? updating,
    TResult Function()? unavailable,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BookOfflineStatusUnknown value) unknown,
    required TResult Function(BookOfflineStatusAvailable value) available,
    required TResult Function(BookOfflineStatusUnableToDownload value)
        unableToDownload,
    required TResult Function(BookOfflineStatusUpdating value) updating,
    required TResult Function(BookOfflineStatusUnavailable value) unavailable,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BookOfflineStatusUnknown value)? unknown,
    TResult? Function(BookOfflineStatusAvailable value)? available,
    TResult? Function(BookOfflineStatusUnableToDownload value)?
        unableToDownload,
    TResult? Function(BookOfflineStatusUpdating value)? updating,
    TResult? Function(BookOfflineStatusUnavailable value)? unavailable,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BookOfflineStatusUnknown value)? unknown,
    TResult Function(BookOfflineStatusAvailable value)? available,
    TResult Function(BookOfflineStatusUnableToDownload value)? unableToDownload,
    TResult Function(BookOfflineStatusUpdating value)? updating,
    TResult Function(BookOfflineStatusUnavailable value)? unavailable,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class BookOfflineStatusUnknown extends BookOfflineStatus {
  const factory BookOfflineStatusUnknown() = _$BookOfflineStatusUnknown;
  const BookOfflineStatusUnknown._() : super._();
}

/// @nodoc
abstract class _$$BookOfflineStatusAvailableCopyWith<$Res> {
  factory _$$BookOfflineStatusAvailableCopyWith(
          _$BookOfflineStatusAvailable value,
          $Res Function(_$BookOfflineStatusAvailable) then) =
      __$$BookOfflineStatusAvailableCopyWithImpl<$Res>;
}

/// @nodoc
class __$$BookOfflineStatusAvailableCopyWithImpl<$Res>
    extends _$BookOfflineStatusCopyWithImpl<$Res, _$BookOfflineStatusAvailable>
    implements _$$BookOfflineStatusAvailableCopyWith<$Res> {
  __$$BookOfflineStatusAvailableCopyWithImpl(
      _$BookOfflineStatusAvailable _value,
      $Res Function(_$BookOfflineStatusAvailable) _then)
      : super(_value, _then);
}

/// @nodoc

class _$BookOfflineStatusAvailable extends BookOfflineStatusAvailable {
  const _$BookOfflineStatusAvailable() : super._();

  @override
  String toString() {
    return 'BookOfflineStatus.available()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BookOfflineStatusAvailable);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function() available,
    required TResult Function() unableToDownload,
    required TResult Function(bool isSaving) updating,
    required TResult Function() unavailable,
  }) {
    return available();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function()? available,
    TResult? Function()? unableToDownload,
    TResult? Function(bool isSaving)? updating,
    TResult? Function()? unavailable,
  }) {
    return available?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function()? available,
    TResult Function()? unableToDownload,
    TResult Function(bool isSaving)? updating,
    TResult Function()? unavailable,
    required TResult orElse(),
  }) {
    if (available != null) {
      return available();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BookOfflineStatusUnknown value) unknown,
    required TResult Function(BookOfflineStatusAvailable value) available,
    required TResult Function(BookOfflineStatusUnableToDownload value)
        unableToDownload,
    required TResult Function(BookOfflineStatusUpdating value) updating,
    required TResult Function(BookOfflineStatusUnavailable value) unavailable,
  }) {
    return available(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BookOfflineStatusUnknown value)? unknown,
    TResult? Function(BookOfflineStatusAvailable value)? available,
    TResult? Function(BookOfflineStatusUnableToDownload value)?
        unableToDownload,
    TResult? Function(BookOfflineStatusUpdating value)? updating,
    TResult? Function(BookOfflineStatusUnavailable value)? unavailable,
  }) {
    return available?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BookOfflineStatusUnknown value)? unknown,
    TResult Function(BookOfflineStatusAvailable value)? available,
    TResult Function(BookOfflineStatusUnableToDownload value)? unableToDownload,
    TResult Function(BookOfflineStatusUpdating value)? updating,
    TResult Function(BookOfflineStatusUnavailable value)? unavailable,
    required TResult orElse(),
  }) {
    if (available != null) {
      return available(this);
    }
    return orElse();
  }
}

abstract class BookOfflineStatusAvailable extends BookOfflineStatus {
  const factory BookOfflineStatusAvailable() = _$BookOfflineStatusAvailable;
  const BookOfflineStatusAvailable._() : super._();
}

/// @nodoc
abstract class _$$BookOfflineStatusUnableToDownloadCopyWith<$Res> {
  factory _$$BookOfflineStatusUnableToDownloadCopyWith(
          _$BookOfflineStatusUnableToDownload value,
          $Res Function(_$BookOfflineStatusUnableToDownload) then) =
      __$$BookOfflineStatusUnableToDownloadCopyWithImpl<$Res>;
}

/// @nodoc
class __$$BookOfflineStatusUnableToDownloadCopyWithImpl<$Res>
    extends _$BookOfflineStatusCopyWithImpl<$Res,
        _$BookOfflineStatusUnableToDownload>
    implements _$$BookOfflineStatusUnableToDownloadCopyWith<$Res> {
  __$$BookOfflineStatusUnableToDownloadCopyWithImpl(
      _$BookOfflineStatusUnableToDownload _value,
      $Res Function(_$BookOfflineStatusUnableToDownload) _then)
      : super(_value, _then);
}

/// @nodoc

class _$BookOfflineStatusUnableToDownload
    extends BookOfflineStatusUnableToDownload {
  const _$BookOfflineStatusUnableToDownload() : super._();

  @override
  String toString() {
    return 'BookOfflineStatus.unableToDownload()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BookOfflineStatusUnableToDownload);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function() available,
    required TResult Function() unableToDownload,
    required TResult Function(bool isSaving) updating,
    required TResult Function() unavailable,
  }) {
    return unableToDownload();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function()? available,
    TResult? Function()? unableToDownload,
    TResult? Function(bool isSaving)? updating,
    TResult? Function()? unavailable,
  }) {
    return unableToDownload?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function()? available,
    TResult Function()? unableToDownload,
    TResult Function(bool isSaving)? updating,
    TResult Function()? unavailable,
    required TResult orElse(),
  }) {
    if (unableToDownload != null) {
      return unableToDownload();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BookOfflineStatusUnknown value) unknown,
    required TResult Function(BookOfflineStatusAvailable value) available,
    required TResult Function(BookOfflineStatusUnableToDownload value)
        unableToDownload,
    required TResult Function(BookOfflineStatusUpdating value) updating,
    required TResult Function(BookOfflineStatusUnavailable value) unavailable,
  }) {
    return unableToDownload(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BookOfflineStatusUnknown value)? unknown,
    TResult? Function(BookOfflineStatusAvailable value)? available,
    TResult? Function(BookOfflineStatusUnableToDownload value)?
        unableToDownload,
    TResult? Function(BookOfflineStatusUpdating value)? updating,
    TResult? Function(BookOfflineStatusUnavailable value)? unavailable,
  }) {
    return unableToDownload?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BookOfflineStatusUnknown value)? unknown,
    TResult Function(BookOfflineStatusAvailable value)? available,
    TResult Function(BookOfflineStatusUnableToDownload value)? unableToDownload,
    TResult Function(BookOfflineStatusUpdating value)? updating,
    TResult Function(BookOfflineStatusUnavailable value)? unavailable,
    required TResult orElse(),
  }) {
    if (unableToDownload != null) {
      return unableToDownload(this);
    }
    return orElse();
  }
}

abstract class BookOfflineStatusUnableToDownload extends BookOfflineStatus {
  const factory BookOfflineStatusUnableToDownload() =
      _$BookOfflineStatusUnableToDownload;
  const BookOfflineStatusUnableToDownload._() : super._();
}

/// @nodoc
abstract class _$$BookOfflineStatusUpdatingCopyWith<$Res> {
  factory _$$BookOfflineStatusUpdatingCopyWith(
          _$BookOfflineStatusUpdating value,
          $Res Function(_$BookOfflineStatusUpdating) then) =
      __$$BookOfflineStatusUpdatingCopyWithImpl<$Res>;
  @useResult
  $Res call({bool isSaving});
}

/// @nodoc
class __$$BookOfflineStatusUpdatingCopyWithImpl<$Res>
    extends _$BookOfflineStatusCopyWithImpl<$Res, _$BookOfflineStatusUpdating>
    implements _$$BookOfflineStatusUpdatingCopyWith<$Res> {
  __$$BookOfflineStatusUpdatingCopyWithImpl(_$BookOfflineStatusUpdating _value,
      $Res Function(_$BookOfflineStatusUpdating) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isSaving = null,
  }) {
    return _then(_$BookOfflineStatusUpdating(
      isSaving: null == isSaving
          ? _value.isSaving
          : isSaving // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$BookOfflineStatusUpdating extends BookOfflineStatusUpdating {
  const _$BookOfflineStatusUpdating({required this.isSaving}) : super._();

  @override
  final bool isSaving;

  @override
  String toString() {
    return 'BookOfflineStatus.updating(isSaving: $isSaving)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BookOfflineStatusUpdating &&
            (identical(other.isSaving, isSaving) ||
                other.isSaving == isSaving));
  }

  @override
  int get hashCode => Object.hash(runtimeType, isSaving);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BookOfflineStatusUpdatingCopyWith<_$BookOfflineStatusUpdating>
      get copyWith => __$$BookOfflineStatusUpdatingCopyWithImpl<
          _$BookOfflineStatusUpdating>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function() available,
    required TResult Function() unableToDownload,
    required TResult Function(bool isSaving) updating,
    required TResult Function() unavailable,
  }) {
    return updating(isSaving);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function()? available,
    TResult? Function()? unableToDownload,
    TResult? Function(bool isSaving)? updating,
    TResult? Function()? unavailable,
  }) {
    return updating?.call(isSaving);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function()? available,
    TResult Function()? unableToDownload,
    TResult Function(bool isSaving)? updating,
    TResult Function()? unavailable,
    required TResult orElse(),
  }) {
    if (updating != null) {
      return updating(isSaving);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BookOfflineStatusUnknown value) unknown,
    required TResult Function(BookOfflineStatusAvailable value) available,
    required TResult Function(BookOfflineStatusUnableToDownload value)
        unableToDownload,
    required TResult Function(BookOfflineStatusUpdating value) updating,
    required TResult Function(BookOfflineStatusUnavailable value) unavailable,
  }) {
    return updating(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BookOfflineStatusUnknown value)? unknown,
    TResult? Function(BookOfflineStatusAvailable value)? available,
    TResult? Function(BookOfflineStatusUnableToDownload value)?
        unableToDownload,
    TResult? Function(BookOfflineStatusUpdating value)? updating,
    TResult? Function(BookOfflineStatusUnavailable value)? unavailable,
  }) {
    return updating?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BookOfflineStatusUnknown value)? unknown,
    TResult Function(BookOfflineStatusAvailable value)? available,
    TResult Function(BookOfflineStatusUnableToDownload value)? unableToDownload,
    TResult Function(BookOfflineStatusUpdating value)? updating,
    TResult Function(BookOfflineStatusUnavailable value)? unavailable,
    required TResult orElse(),
  }) {
    if (updating != null) {
      return updating(this);
    }
    return orElse();
  }
}

abstract class BookOfflineStatusUpdating extends BookOfflineStatus {
  const factory BookOfflineStatusUpdating({required final bool isSaving}) =
      _$BookOfflineStatusUpdating;
  const BookOfflineStatusUpdating._() : super._();

  bool get isSaving;
  @JsonKey(ignore: true)
  _$$BookOfflineStatusUpdatingCopyWith<_$BookOfflineStatusUpdating>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BookOfflineStatusUnavailableCopyWith<$Res> {
  factory _$$BookOfflineStatusUnavailableCopyWith(
          _$BookOfflineStatusUnavailable value,
          $Res Function(_$BookOfflineStatusUnavailable) then) =
      __$$BookOfflineStatusUnavailableCopyWithImpl<$Res>;
}

/// @nodoc
class __$$BookOfflineStatusUnavailableCopyWithImpl<$Res>
    extends _$BookOfflineStatusCopyWithImpl<$Res,
        _$BookOfflineStatusUnavailable>
    implements _$$BookOfflineStatusUnavailableCopyWith<$Res> {
  __$$BookOfflineStatusUnavailableCopyWithImpl(
      _$BookOfflineStatusUnavailable _value,
      $Res Function(_$BookOfflineStatusUnavailable) _then)
      : super(_value, _then);
}

/// @nodoc

class _$BookOfflineStatusUnavailable extends BookOfflineStatusUnavailable {
  const _$BookOfflineStatusUnavailable() : super._();

  @override
  String toString() {
    return 'BookOfflineStatus.unavailable()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BookOfflineStatusUnavailable);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function() available,
    required TResult Function() unableToDownload,
    required TResult Function(bool isSaving) updating,
    required TResult Function() unavailable,
  }) {
    return unavailable();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function()? available,
    TResult? Function()? unableToDownload,
    TResult? Function(bool isSaving)? updating,
    TResult? Function()? unavailable,
  }) {
    return unavailable?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function()? available,
    TResult Function()? unableToDownload,
    TResult Function(bool isSaving)? updating,
    TResult Function()? unavailable,
    required TResult orElse(),
  }) {
    if (unavailable != null) {
      return unavailable();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BookOfflineStatusUnknown value) unknown,
    required TResult Function(BookOfflineStatusAvailable value) available,
    required TResult Function(BookOfflineStatusUnableToDownload value)
        unableToDownload,
    required TResult Function(BookOfflineStatusUpdating value) updating,
    required TResult Function(BookOfflineStatusUnavailable value) unavailable,
  }) {
    return unavailable(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BookOfflineStatusUnknown value)? unknown,
    TResult? Function(BookOfflineStatusAvailable value)? available,
    TResult? Function(BookOfflineStatusUnableToDownload value)?
        unableToDownload,
    TResult? Function(BookOfflineStatusUpdating value)? updating,
    TResult? Function(BookOfflineStatusUnavailable value)? unavailable,
  }) {
    return unavailable?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BookOfflineStatusUnknown value)? unknown,
    TResult Function(BookOfflineStatusAvailable value)? available,
    TResult Function(BookOfflineStatusUnableToDownload value)? unableToDownload,
    TResult Function(BookOfflineStatusUpdating value)? updating,
    TResult Function(BookOfflineStatusUnavailable value)? unavailable,
    required TResult orElse(),
  }) {
    if (unavailable != null) {
      return unavailable(this);
    }
    return orElse();
  }
}

abstract class BookOfflineStatusUnavailable extends BookOfflineStatus {
  const factory BookOfflineStatusUnavailable() = _$BookOfflineStatusUnavailable;
  const BookOfflineStatusUnavailable._() : super._();
}
